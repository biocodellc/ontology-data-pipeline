# Copyright (C) 2017 Brian J. Stucky
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Provides high-level management of the imports and ontology build process by
# providing a framework for implementing discrete build targets.  Each build
# target is a concrete subclass of the abstract base classes BuildTarget or
# BuildTargetWithConfig (itself a subclass of BuildTarget), both of which are
# defined in this module.  Targets can be linked together in dependency
# relationships, and build products from dependencies are (optionally) passed
# up the dependency chain to their dependent targets so that high-level build
# targets can directly use the results of low-level build targets.
#

# Python imports.
from __future__ import unicode_literals
import abc
import os, shutil
from contextlib import contextmanager
import tempfile
from zipfile import ZipFile
from ontoconfig import OntoConfig

# Java imports.


class BuildTarget:
    """
    An abstract base class for all concrete build target classes.
    """
    def __init__(self):
        # This is an abstract base class.
        __metaclass__ = abc.ABCMeta

        # A list of references to the build targets on which this build target
        # depends.
        self.dependencies = []

        # A dictionary to accumulate the build products generated by the build
        # targets on which this target depends.
        self.products = {}

        # Define default error messages for directory creation errors.
        self.bad_dirpath_msg = (
            'A file with the same name as the build target folder, "{0}", '
            'already exists.  Please delete, move, or rename the conflicting '
            'file before continuing.'
        )
        self.bad_dirperms_msg = (
            'The build target folder, "{0}", could not be created.  Please '
            'make sure that you have permission to create new files and '
            'directories in the project location.'
        )

    def _makeDirs(self, dirpath, bad_dirpath_msg='', bad_dirperms_msg=''):
        """
        Attempts to create one or more directories in a path string.  If a
        non-directory file system object with same name already exists, or if
        directory creation fails for some other reason, an exception will be
        thrown.

        dirpath (str): The directory path to create.
        bad_dirpath_msg (str, optional): A custom exception message for
            conflicting path errors.
        bad_dirperms_msg (str, optional): A custom exception message for
            directory creation failure errors.
        """
        if bad_dirpath_msg == '':
            bad_dirpath_msg = self.bad_dirpath_msg
        if bad_dirperms_msg == '':
            bad_dirperms_msg = self.bad_dirperms_msg

        if os.path.exists(dirpath):
            if not(os.path.isdir(dirpath)):
                raise RuntimeError(bad_dirpath_msg.format(dirpath))

        if not(os.path.exists(dirpath)):
            try:
                os.makedirs(dirpath)
            except OSError:
                raise RuntimeError(bad_dirperms_msg.format(dirpath))

    @contextmanager
    def getSourceDirectory(self, dirpath):
        """
        Implements a context manager that returns the path to a directory in
        the OntoPilot installation location.  If OntoPilot is run from a JAR
        file, a temporary directory will be created, the relevant source
        directory will be extracted from the JAR, and the temporary directory
        will be deleted upon context exit.

        dirpath: A directory path string relative to the root of the OntoPilot
            installation.
        """
        tmpdir = ''
        sourcedir = ''

        script_path = os.path.abspath(os.path.realpath(__file__))

        if ('.jar/Lib' in script_path) or ('.jar\\Lib' in script_path):
            # We're running from a JAR file, so we need to extract the source
            # files to a temporary location.
            jar_path = script_path.rpartition('.jar')[0] + '.jar'
            zip_ref = ZipFile(jar_path)

            # Extract the files into a temporary directory.
            tmpdir = tempfile.mkdtemp()
            for filepath in zip_ref.namelist():
                if filepath.startswith(dirpath):
                    zip_ref.extract(filepath, tmpdir)

            sourcedir = os.path.join(tmpdir, dirpath)
        else:
            # We're not running from a JAR file, so we can directly access the
            # source files from the installation location.
            sourcedir = os.path.abspath(os.path.join(
                os.path.dirname(script_path), '../../', dirpath
            ))

        try:
            yield sourcedir
        finally:
            if tmpdir != '':
                shutil.rmtree(tmpdir)

    def addDependency(self, target):
        """
        Adds a dependency for this build target.
        """
        self.dependencies.append(target)

    def isBuildRequired(self):
        """
        Determines if the build task needs to be run.  Inspects the state of
        all dependencies as well as this build target.  If any dependencies
        require a build, than this method will automatically return True.
        """
        for dependency in self.dependencies:
            if dependency.isBuildRequired():
                return True

        return self._isBuildRequired()

    def run(self, force_build=False):
        """
        Runs this build task.  All dependencies are processed first.  If the
        build task fails, an appropriate exception should be thrown, and
        exceptions should be allowed to "bubble up" through the dependency
        chain so they can be properly handled by external client code.

        force_build: If True, the build task (including all dependencies) will
            be run, even if all build products appear to be up to date.
        """
        # Invalidate any previous build products.
        self.products.clear()

        dependencies_run = False
        for dependency in self.dependencies:
            results = {}
            if dependency.isBuildRequired() or force_build:
                dependencies_run = True
                results = dependency.run(force_build)

            # Merge the results with the products dictionary, making sure we
            # don't have any duplicate keys.
            for key in results:
                if key not in self.products:
                    self.products[key] = results[key]
                else:
                    raise RuntimeError(
                        'Unable to merge product returned from build target \
{0} into the build products set for build target {1} because of a duplicate \
product name key: "{2}".'.format(
                            dependency.__class__.__name__, self.__class__.__name__, key
                        )
                    )

        # Run the build task for this target.  If we ran any dependencies, we
        # should always run this build task even if the local
        # _isBuildRequired() returns False.
        if self._isBuildRequired() or dependencies_run or force_build:
            results = self._run()
            if results is None:
                results = {}
        else:
            results = {}

        # Merge the results of this build target with the products accumulated
        # from lower-level build targets, again making sure we don't have any
        # duplicate keys.
        for key in results:
            if key not in self.products:
                self.products[key] = results[key]
            else:
                raise RuntimeError(
                    'A build product from build target {0} could not be \
merged into the build products set because it uses a product name key that \
duplicates one of its dependency\'s product name keys: "{1}".'.format(
                        self.__class__.__name__, key
                    )
                )

        return self.products
    
    def getBuildNotRequiredMsg(self):
        """
        Returns a string with a target-appropriate message to indicate that
        running the build process is not required.  This can be overridden by
        child classes to provide helpful information for user interfaces.
        """
        return ''

    @abc.abstractmethod
    def _isBuildRequired(self):
        """
        This method must be implemented by child classes.  It should return
        True if a build is required, False otherwise.
        """
        pass

    @abc.abstractmethod
    def _run(self):
        """
        Runs the build task for this particular build target.  This method must
        be implemented by child classes.  When this method is invoked, all
        build targets on which this target depends will have already been run,
        and the results will be in the dictionary self.products.  This method
        should return a dictionary (which may be empty) of build products.
        Alternatively, the method can return None (or have no return statement)
        if no build products need to be passed up the dependency chain.
        """
        return {}


class BuildTargetWithConfig(BuildTarget):
    """
    An abstract base class for build targets that require an instance of an
    OntoConfig object.
    """
    def __init__(self, args, cfgfile_required=True, config=None):
        """
        This constructor will attempt to instantiate an OntoConfig instance
        from the value of the 'config_file' member of args.  If
        cfgfile_required is True, and no config file could be loaded, an
        exception will be raised.  If no config file path is provided,
        "project.conf" will be used by default.  If cfgfile_required is False
        and config is an OntoConfig object, the config will be used as the
        OntoConfig object for this instance.

        args: A "struct" of configuration options (typically, parsed
            command-line arguments).  The only required member is
            'config_file', which should provide the path to a configuration
            file (although this is only used if the config argument is None).
        cfgfile_required (optional): Whether a config file is required.
        config (optional): An OntoConfig object.
        """
        BuildTarget.__init__(self)

        if not(cfgfile_required) and (config is not None):
            self.config = config
        else:
            cfilepath = args.config_file.strip()
            if cfilepath == '':
                cfilepath = 'project.conf'
    
            try:
                self.config = OntoConfig(cfilepath)
            except IOError as err:
                if not(cfgfile_required):
                    self.config = OntoConfig()
                else:
                    raise RuntimeError(
                        'Unable to load the project configuration file.  '
                        'Please make sure the configuration file exists and '
                        'that the path ("{0}") is correct.  Use the "-c" '
                        '(or "--config_file") option to specify a different '
                        'configuration file or path.'.format(cfilepath)
                    )

    def getConfig(self):
        """
        Returns the OntoConfig object associated with this build target.
        """
        return self.config

